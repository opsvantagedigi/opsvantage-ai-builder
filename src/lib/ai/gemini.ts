// Placeholder for a real Gemini client
// In a real app, this would use the Google AI SDK
// e.g., import { GoogleGenerativeAI } from "@google/generative-ai";

export async function getGenerativeModel(modelName: string = 'gemini-pro') {
  console.log('[GENERIC_MODEL] using model:', modelName);
  // const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!);
  // return genAI.getGenerativeModel({ model: modelName });

  // Mock implementation for now
  return {
    generateContent: async (prompt: string): Promise<{ response: { text: () => string } }> => {
      console.log('--- MOCK GEMINI PROMPT ---');
      console.log(prompt.substring(0, 500) + '...');
      console.log('--------------------------');

      // Simulate network delay
      await new Promise(resolve => setTimeout(resolve, 1500));

      if (prompt.includes('generate a sitemap')) {
        const mockSitemap = [
          { title: 'Home', slug: '/', type: 'HOME', isHome: true },
          { title: 'About Us', slug: '/about', type: 'CUSTOM', isHome: false },
          { title: 'Services', slug: '/services', type: 'CUSTOM', isHome: false },
          { title: 'Contact Us', slug: '/contact', type: 'CUSTOM', isHome: false },
        ];
        return {
          response: { text: () => `\`\`\`json\n${JSON.stringify(mockSitemap, null, 2)}\n\`\`\`` },
        };
      }

      if (prompt.includes('generate the content for a webpage')) {
        const mockPageData = {
          seoTitle: "Mock SEO Title for the Page",
          seoDescription: "This is a mock SEO-optimized meta description, designed to be around 155 characters to fit best practices for search engine results pages.",
          sections: [
            {
              type: 'HERO',
              variant: 'default',
              data: {
                headline: 'Dynamic Headline Generated by AI',
                subheadline: 'A compelling subheadline that grabs user attention and drives conversion.',
                cta: { text: 'Learn More', link: '/about' },
                imageSuggestions: ["A vibrant abstract background with geometric shapes, in the brand's primary colors.", "A photorealistic image of a person looking up at a bright sky, symbolizing future and growth."],
                colorRecommendations: [
                  { "name": "Primary", "hex": "#3B82F6" },
                  { "name": "Accent", "hex": "#10B981" },
                  { "name": "Background", "hex": "#F9FAFB" }
                ],
                typographyRecommendations: [
                  { "element": "Headline", "fontFamily": "Inter", "fontWeight": 800 },
                  { "element": "Body", "fontFamily": "Roboto", "fontWeight": 400 }
                ]
              },
            },
          ],
        };
        return {
          response: { text: () => `\`\`\`json\n${JSON.stringify(mockPageData, null, 2)}\n\`\`\`` },
        };
      }

      if (prompt.includes('generate the content for a single new webpage section')) {
        const sectionTypeMatch = prompt.match(/Generate a single section of type: (\w+)/);
        const sectionType = sectionTypeMatch ? sectionTypeMatch[1] : 'CUSTOM';

        const mockSection = {
            type: sectionType,
            variant: 'default',
            data: {
                headline: `Newly Generated ${sectionType} Section`,
                subheadline: 'This section was generated on-demand by the AI Section Generator.',
                items: [
                    { title: 'Dynamic Item 1', description: 'Description for item 1.', imageSuggestions: ["A close-up shot of a mechanical gear turning, symbolizing process and precision."] },
                    { title: 'Dynamic Item 2', description: 'Description for item 2.', imageSuggestions: ["A person sketching a new idea on a whiteboard, representing innovation."] },
                ]
            },
        };
        return {
            response: { text: () => `\`\`\`json\n${JSON.stringify(mockSection, null, 2)}\n\`\`\`` },
        };
      }

      if (prompt.includes('Your task is to refine a piece of text')) {
        const instructionMatch = prompt.match(/Instruction: (.*?)\n/);
        const instruction = instructionMatch ? instructionMatch[1] : "Refine";
        const originalTextMatch = prompt.match(/Original Text:\n---\n([\s\S]*?)\n---/);
        const originalText = originalTextMatch ? originalTextMatch[1].trim() : "text";
        return {
          response: { text: () => `[${instruction}] This is the AI-refined version of "${originalText}".` },
        };
      }

      // Fallback for unknown prompts
      return { response: { text: () => '```json\n{}\n```' } };
    },
  };
}